import { FixProposal, PRData, CreatedPR, FileChange } from '../models';

/**
 * Creates pull requests with test fixes
 */
export class PRCreator {
  /**
   * Converts a fix proposal into PR data
   */
  preparePRData(
    proposal: FixProposal,
    owner: string,
    repo: string,
    baseBranch: string = 'main'
  ): PRData {
    const successfulFixes = proposal.fixes.filter(f => f.success);
    const branchName = `test-fix/${proposal.commitSha.slice(0, 7)}-${Date.now()}`;

    // Group fixes by file
    const fileChanges = this.groupFixesByFile(successfulFixes);

    const title = this.generateTitle(successfulFixes);
    const description = this.generateDescription(proposal);

    return {
      owner,
      repo,
      baseBranch,
      title,
      description,
      branchName,
      changes: fileChanges,
      commitMessage: `fix: automated test fixes for build ${proposal.buildNumber}`,
      labels: ['automated-fix', 'tests']
    };
  }

  /**
   * Groups multiple fixes for the same file into a single change
   */
  private groupFixesByFile(fixes: any[]): FileChange[] {
    const fileMap = new Map<string, any[]>();

    // Group fixes by file path
    for (const fix of fixes) {
      if (!fileMap.has(fix.filePath)) {
        fileMap.set(fix.filePath, []);
      }
      fileMap.get(fix.filePath)!.push(fix);
    }

    // Create file changes
    const changes: FileChange[] = [];
    for (const [path, fileFixes] of fileMap) {
      // Apply all fixes to the file sequentially
      let content = fileFixes[0].originalCode;
      for (const fix of fileFixes) {
        content = content.replace(fix.originalCode, fix.fixedCode);
      }

      changes.push({
        path,
        content,
        operation: 'update'
      });
    }

    return changes;
  }

  /**
   * Generates PR title based on fixes
   */
  private generateTitle(fixes: any[]): string {
    if (fixes.length === 1) {
      return `Fix: ${fixes[0].strategy} test failure`;
    }

    const strategies = new Set(fixes.map(f => f.strategy));
    if (strategies.size === 1) {
      return `Fix: ${fixes.length} ${Array.from(strategies)[0]} test failures`;
    }

    return `Fix: ${fixes.length} test failures`;
  }

  /**
   * Generates detailed PR description
   */
  private generateDescription(proposal: FixProposal): string {
    const successfulFixes = proposal.fixes.filter(f => f.success);
    const failedFixes = proposal.fixes.filter(f => !f.success);

    let description = '## Automated Test Fixes\n\n';
    description += `This PR automatically fixes ${successfulFixes.length} test failure(s) `;
    description += `detected in build #${proposal.buildNumber}.\n\n`;

    description += `**Estimated time saved**: ~${proposal.estimatedTimesSaved} minutes\n\n`;
    description += `**Overall confidence**: ${(proposal.totalConfidence * 100).toFixed(0)}%\n\n`;

    description += '### Changes Made\n\n';
    for (const fix of successfulFixes) {
      description += `#### ${fix.filePath}\n`;
      description += `- **Strategy**: ${fix.strategy}\n`;
      description += `- **Confidence**: ${(fix.confidence * 100).toFixed(0)}%\n`;
      description += `- **Explanation**: ${fix.explanation}\n\n`;
    }

    if (failedFixes.length > 0) {
      description += '### Unable to Fix\n\n';
      description += 'The following failures require manual review:\n\n';
      for (const fix of failedFixes) {
        description += `- **${fix.filePath}**: ${fix.explanation}\n`;
      }
      description += '\n';
    }

    description += '---\n';
    description += '*ðŸ¤– Generated by TestFixer AI*\n';

    return description;
  }
}
